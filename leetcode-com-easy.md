## ðŸ§© Binary Prefix Divisible By 5

**Source**: [Binary Prefix Divisible By 5](https://leetcode.com/problems/binary-prefix-divisible-by-5/submissions/)

**Description**:

> You are given a binary arrayÂ `nums`Â (**0-indexed**).
> 
> We defineÂ `xi`Â as the number whose binary representation is the subarrayÂ `nums[0..i]`Â (from most-significant-bit to least-significant-bit).
> 
> - For example, ifÂ `nums = [1,0,1]`, thenÂ `x0Â = 1`,Â `x1Â = 2`, andÂ `x2Â = 5`.
> 
> ReturnÂ *an array of booleans* `answer` *where* `answer[i]` *is* `true` *if* `xi` *is divisible by* `5`.

**Answer**:

```python
return reduce(lambda p, n: [p[0] + str(n), p[1] + [int(p[0] + str(n), 2)%5 == 0]], [["", []]] + nums)[1]
```

## ðŸ§© Minimum Add to Make Parentheses Valid

**Source**: [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

**Description**:

> A parentheses string is valid if and only if:
> 
> - It is the empty string,
> - It can be written asÂ `AB`Â (`A`Â concatenated withÂ `B`), whereÂ `A`Â andÂ `B`Â are valid strings, or
> - It can be written asÂ `(A)`, whereÂ `A`Â is a valid string.
> 
> You are given a parentheses stringÂ `s`. In one move, you can insert a parenthesis at any position of the string.
> 
> - For example, ifÂ `s = "()))"`, you can insert an opening parenthesis to beÂ `"(**(**)))"`Â or a closing parenthesis to beÂ `"())**)**)"`.
> 
> ReturnÂ *the minimum number of moves required to make* `s` *valid*.

**Answer**:

```python
return len(functools.reduce(lambda c1, c2: c2 if not c1 else c1[:-1] if c2==")" and c1[-1] == "(" else c1 + c2, s)) if s else len(s)
```

**Explanations**:

Uses PythonÂ `reduce()`Â on string s, whenever it has '()' in the result ofÂ `reduce()`Â step then remove this from string.

- Can useÂ `''.join((c1, c2)).replace("()", "")`Â but the performance is pretty bad.
- `c2 if not c1 else ...`: prevent Exception onÂ `c1[:-1]`Â when c1 is empty.
- `c1[:-1] if c2==")" and c1[-1] == "(" else c1 + c2`: ifÂ `c1 + c2`Â ends withÂ `()`, then takeÂ `c1[:1]`Â only, else takeÂ `c1 + c2`.


## ðŸ§© Remove Palindromic Subsequences

**Source**: [Remove Palindromic Subsequences](https://leetcode.com/problems/remove-palindromic-subsequences/)

**Description**:

> You are given a string `s` consisting **only** of letters '`a`' and '`b`'. In a single step you can remove one **palindromic subsequence** from `s`.
>
> _Return the **minimum** number of steps to make the given string empty._
>
> A string is a **subsequence** of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does **not** necessarily need to be contiguous.
>
> A string is called **palindrome** if is one that reads the same backward as well as forward.

**Answer**:

```python
return 2 - (s == s[::-1]) - (s == "")
```

**Explanations**:

The problem is more of a brainteaser. Since, we can remove **palindromic subsequence**. Hence, 
- If `s` is empty, answer would be **0** since we need 0 steps to make the given string empty.
- If `s` is palindrome, answer would be **1** since we can remove the entire string, since entire string is palindromic subsequence.
- If `s` isn't palindrome, we can take all `a`'s as a subsequence. This will be palindromic subsequence, remove it. At next step, we can take all `b`'s as a subesequecne, this will be a palindromic subsequence, remove it. Hence, answer would be **2**

Thus, atmost we can have minimum as `2`, we can subtract `1` from it if `s` is a palindrome, can subtract another `1` if `s` is empty. Hence, the python one-liner! 

## ğŸ§© Binary Prefix Divisible By 5

**Source**: [Binary Prefix Divisible By 5](https://leetcode.com/problems/binary-prefix-divisible-by-5/submissions/)

**Description**:

> You are given a binary arrayÂ `nums`Â (**0-indexed**).
> 
> We defineÂ `xi`Â as the number whose binary representation is the subarrayÂ `nums[0..i]`Â (from most-significant-bit to least-significant-bit).
> 
> - For example, ifÂ `nums = [1,0,1]`, thenÂ `x0Â = 1`,Â `x1Â = 2`, andÂ `x2Â = 5`.
> 
> ReturnÂ *an array of booleans* `answer` *where* `answer[i]` *is* `true` *if* `xi` *is divisible by* `5`.

**Answer**:

```python
return reduce(lambda p, n: [p[0] + str(n), p[1] + [int(p[0] + str(n), 2)%5 == 0]], [["", []]] + nums)[1]
```

## ğŸ§© Minimum Add to Make Parentheses Valid

**Source**: [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

**Description**:

> A parentheses string is valid if and only if:
> 
> - It is the empty string,
> - It can be written asÂ `AB`Â (`A`Â concatenated withÂ `B`), whereÂ `A`Â andÂ `B`Â are valid strings, or
> - It can be written asÂ `(A)`, whereÂ `A`Â is a valid string.
> 
> You are given a parentheses stringÂ `s`. In one move, you can insert a parenthesis at any position of the string.
> 
> - For example, ifÂ `s = "()))"`, you can insert an opening parenthesis to beÂ `"(**(**)))"`Â or a closing parenthesis to beÂ `"())**)**)"`.
> 
> ReturnÂ *the minimum number of moves required to make* `s` *valid*.

**Answer**:

```python
return len(functools.reduce(lambda c1, c2: c2 if not c1 else c1[:-1] if c2==")" and c1[-1] == "(" else c1 + c2, s)) if s else len(s)
```

**Explanations**:

Uses PythonÂ `reduce()`Â on string s, whenever it has '()' in the result ofÂ `reduce()`Â step then remove this from string.

- Can useÂ `''.join((c1, c2)).replace("()", "")`Â but the performance is pretty bad.
- `c2 if not c1 else ...`: prevent Exception onÂ `c1[:-1]`Â when c1 is empty.
- `c1[:-1] if c2==")" and c1[-1] == "(" else c1 + c2`: ifÂ `c1 + c2`Â ends withÂ `()`, then takeÂ `c1[:1]`Â only, else takeÂ `c1 + c2`.

## ğŸ§© Palindrome Number

**Source**: [Palindrome Number](https://leetcode.com/problems/palindrome-number/)

**Description**:

> Given an integerÂ `x`, returnÂ `true`Â ifÂ `x`Â is palindrome integer.
> 
> An integer is aÂ **palindrome**Â when it reads the same backward as forward.
> 
> - For example,Â `121`Â is a palindrome whileÂ `123`Â is not.

**Answer**:

```python
return str(x) == str(x)[::-1]
```

## ğŸ§© Remove Palindromic Subsequences

**Source**: [Remove Palindromic Subsequences](https://leetcode.com/problems/remove-palindromic-subsequences/)

**Description**:

> You are given a string `s` consisting **only** of letters '`a`' and '`b`'. In a single step you can remove one **palindromic subsequence** from `s`.
> 
> _Return the **minimum** number of steps to make the given string empty._
> 
> A string is a **subsequence** of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does **not** necessarily need to be contiguous.
> 
> A string is called **palindrome** if is one that reads the same backward as well as forward.

**Answer**:

```python
return 2 - (s == s[::-1]) - (s == "")
```

**Explanations**:

The problem is more of a brainteaser. Since, we can remove **palindromic subsequence**. Hence, 

- If `s` is empty, answer would be **0** since we need 0 steps to make the given string empty.
- If `s` is palindrome, answer would be **1** since we can remove the entire string, since entire string is palindromic subsequence.
- If `s` isn't palindrome, we can take all `a`'s as a subsequence. This will be palindromic subsequence, remove it. At next step, we can take all `b`'s as a subesequecne, this will be a palindromic subsequence, remove it. Hence, answer would be **2**

Thus, atmost we can have minimum as `2`, we can subtract `1` from it if `s` is a palindrome, can subtract another `1` if `s` is empty. Hence, the python one-liner! 

## ğŸ§© Plus One

**Source**: [Plus One](https://leetcode.com/problems/plus-one/)

**Description**:

> You are given aÂ **large integer**Â represented as an integer arrayÂ `digits`, where eachÂ `digits[i]`Â is theÂ `ith`Â digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leadingÂ `0`'s.
> 
> Increment the large integer by one and returnÂ *the resulting array of digits*.

**Answer**:

```python
return list(str(int(''.join(map(str, digits))) + 1))
```

**Explanations**:

- Convert list of numbers to number by join()

- +1 and returns the list of intergers.

## ğŸ§© Valid Palindrome

**Source**: [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/submissions/)

**Description**:

> A phrase is aÂ **palindrome**Â if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
> 
> Given a stringÂ `s`, returnÂ `true` *if it is aÂ **palindrome**, or* `false` *otherwise*.

**Answer**:

```python
return reduce(lambda p, c: p+c if c.isalpha() or c.isnumeric() else p, ' ' + s).lower().strip() == reduce(lambda p, c: p+c if c.isalpha() or c.isnumeric() else p, ' ' + s).lower()[::-1].strip()
```

**Explanations**:

- I don't know why it's not TLE lmao.

## ğŸ§© Squares of a Sorted Array

**Source**: [Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)

**Description**:

> Given an integer array `nums` sorted in **non-decreasing** order, return *an array ofÂ **the squares of each number**Â sorted in non-decreasing order*.

**Answer**:

```python
return sorted(map(lambda n: n*n, nums))
```

## ğŸ§© Sqrt(x)

**Source**: [Sqrt(x)](https://leetcode.com/problems/sqrtx/)

**Description**:

> Given a non-negative integerÂ `x`,Â compute and returnÂ *the square root of*Â `x`.
> 
> Since the return typeÂ is an integer, the decimal digits areÂ **truncated**, and onlyÂ **the integer part**Â of the resultÂ is returned.
> 
> **Note:** You are not allowed to use any built-in exponent function or operator, such asÂ `pow(x, 0.5)`Â orÂ `x ** 0.5`.

**Answer**:

```python
return next((i for i in range(0, x) if i*i > x), 2) - 1 if x > 1 else x
```

**Explanations**:

Note that the requirement is: You are not allowed to use any built-in exponent function or operator, such as `pow(x, 0.5)` or `x ** 0.5`. Without this, the solution could be as easy as: `floor(sqrt(x))`

Solution is to find the first number i that i*i > x, then minus with 1.

- If x = 2, then next() returns default value of 2, 2 - 1 = 1
- Other cases: input 0 returns 0, input 1 returns 1

## ğŸ§© Single Number

**Source**: [Single Number](https://leetcode.com/problems/single-number/)

**Description**:

> Given aÂ **non-empty**Â array of integersÂ `nums`, every element appearsÂ *twice*Â except for one. Find that single one.
> 
> You mustÂ implement a solution with a linear runtime complexity and useÂ only constantÂ extra space.

**Answer 1**:

```python
return sum(set(nums)) * 2 - sum(nums)
```

**Explanation**:

It's just simple mathematic approach.

**Answer 2**:

```python
return reduce(lambda p, n: p ^ n, nums)
```

**Explanation**:

Base on this genius solution from [leetcode](https://leetcode.com/problems/single-number/discuss/1771771/Think-it-through-oror-Time%3A-O(n)-Space%3A-O(1)-oror-Python-Explained).

## ğŸ§© Reverse Bits

**Source**: [Reverse Bits](https://leetcode.com/problems/reverse-bits/)

**Description**:

> Reverse bits of a given 32 bits unsigned integer.
> 
> **Note:**
> 
> - Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
> - In Java, the compiler represents the signed integers usingÂ [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, inÂ **Example 2**Â above, the input represents the signed integerÂ `-3`Â and the output represents the signed integerÂ `-1073741825`.

**Answer**:

```python
return int(bin(n)[2:][::-1].ljust(32, '0'), 2)
```

## ğŸ§© Count Prefixes of a Given String

**Source**: [Count Prefixes of a Given String](https://leetcode.com/problems/count-prefixes-of-a-given-string/)

**Description**:

> You are given a string arrayÂ `words`Â and a stringÂ `s`, whereÂ `words[i]`Â andÂ `s`Â comprise only ofÂ **lowercase English letters**.
> 
> ReturnÂ *theÂ **number of strings**Â in*Â `words`Â *that are aÂ **prefix**Â of*Â `s`.
> 
> AÂ **prefix**Â of a string is a substring that occurs at the beginning of the string. AÂ **substring**Â is a contiguous sequence of characters within a string.

**Answer**:

```python
return len([w for w in words if w == s[:len(w)]])
```

## ğŸ§© Add Two Integers

**Source**: [Add Two Integers](https://leetcode.com/problems/add-two-integers/)

**Description**:

> Given two integers `num1` and `num2`, return *theÂ **sum**Â of the two integers*.

**Answer**:

```python
return num1 + num2
```

## ğŸ§© Find Closest Number to Zero

**Source**: [Find Closest Number to Zero](https://leetcode.com/problems/find-closest-number-to-zero)

**Description**:

> Given an integer array `nums` of size `n`, return *the number with the valueÂ **closest**Â to* `0` *in* `nums`. If there are multiple answers, return *the number with theÂ **largest**Â value*.

**Answer**:

```python
return reduce(lambda a, n: a if abs(a) < abs(n) else max(a, n) if abs(a) == abs(n) else n, nums)
```

## ğŸ§© Percentage of Letter in String

**Source**: [Percentage of Letter in String](https://leetcode.com/problems/percentage-of-letter-in-string)

**Description**:

> Given a string `s` and a character `letter`, return *theÂ **percentage**Â of characters in* `s` *that equal* `letter` **rounded down**Â to the nearest whole percent.

**Answer**:

```python
return s.count(letter) * 100 // len(s)
```

## ğŸ§© Largest 3-Same-Digit Number in String

**Source**: [Largest 3-Same-Digit Number in String](https://leetcode.com/problems/largest-3-same-digit-number-in-string)

**Description**:

> You are given a stringÂ `num`Â representing a large integer. An integer isÂ **good**Â if it meets the following conditions:
> 
> - It is aÂ **substring**Â ofÂ `num`Â with lengthÂ `3`.
> - It consists of only one unique digit.
> 
> ReturnÂ *theÂ **maximum good** integer as aÂ **string**Â or an empty string* `""` *if no such integer exists*.
> 
> Note:
> 
> - AÂ **substring**Â is a contiguous sequence of characters within a string.
> - There may beÂ **leading zeroes**Â inÂ `num`Â or a good integer.

**Answer 1**:

```python
return [triple for triple in ['999','888','777','666','555','444','333','222','111','000',''] if triple in num][0]
```

**Explanations**:

- Check if each triple in inputted `num`.
- The first triple that found is the largest, so get the [0]
- As `''` always in any string, if no triple found in `num`, `[''][0]` is returned.

**Answer 2**:

```python
return next((triple for triple in ['999','888','777','666','555','444','333','222','111','000'] if triple in num), '')
```

**Explanations**:

- Use `next()` to find the first triple.

- The triple list is in decreasing order, the first triple that found is the largest.

- If no triple found, `next()` returns default value of `''`

## ğŸ§© Thousand Separator

**Source**: [Thousand Separator](https://leetcode.com/problems/thousand-separator)

**Description**:

> Given an integer `n`, add a dot (".") as the thousands separator and return it in string format.

**Answer**:

```python
return '.'.join([str(n)[max(0, i-3):i] for i in range(len(str(n)), 0, -3)][::-1])
```

## ğŸ§© Shuffle String

**Source**: [Shuffle String](https://leetcode.com/problems/shuffle-string/)

**Description**:

> You are given a stringÂ `s`Â and an integer arrayÂ `indices`Â of theÂ **same length**. The stringÂ `s`Â will be shuffled such that the character at theÂ `ith`Â position moves toÂ `indices[i]`Â in the shuffled string.
> 
> ReturnÂ *the shuffled string*.

**Answer**:

```python
return ''.join([s[indices.index(i)] for i in range(len(s))])
```

## ğŸ§© Concatenation of Array

**Source**: [Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)

**Description**:

> Given an integer arrayÂ `nums`Â of lengthÂ `n`, you want to create an arrayÂ `ans`Â of lengthÂ `2n`Â whereÂ `ans[i] == nums[i]`Â andÂ `ans[i + n] == nums[i]`Â forÂ `0 <= i < n`Â (**0-indexed**).
> 
> Specifically,Â `ans`Â is theÂ **concatenation**Â of twoÂ `nums`Â arrays.
> 
> ReturnÂ *the array* `ans`.

**Answer**:

```python
return nums*2
```

## ğŸ§© Build Array from Permutation

**Source**: [Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)

**Description**:

> Given aÂ **zero-based permutation**Â `nums`Â (**0-indexed**), build an arrayÂ `ans`Â of theÂ **same length**Â whereÂ `ans[i] = nums[nums[i]]`Â for eachÂ `0 <= i < nums.length`Â and return it.
> 
> AÂ **zero-based permutation**Â `nums`Â is an array ofÂ **distinct**Â integers fromÂ `0`Â toÂ `nums.length - 1`Â (**inclusive**).

**Answer**:

```python
return [nums[nums[i]] for i in range(0, len(nums))]
```

## ğŸ§© Running Sum of 1d Array

**Source**: [Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array)

**Description**:

> Given an arrayÂ `nums`. We define a running sum of an array asÂ `runningSum[i] = sum(nums[0]â€¦nums[i])`.
> 
> Return the running sum ofÂ `nums`.

**Answer**:

```python
return accumulate(nums)
# Using reduce
return reduce(lambda p, n: p + [p[-1] + n], [[0]] + nums)[1:]
# Using list comprehension with sum()
return [sum(nums[:i]) for i in range(1, len(nums) + 1)]
```

**Bonus**:

This [answer](https://leetcode.com/problems/running-sum-of-1d-array/discuss/841274/Python-3-Multiple-One-Liners/925943) is hilarious:

```python
class Solution:
    runningSum=accumulate
```

## ğŸ§© Final Value of Variable After Performing Operations

**Source**: [Final Value of Variable After Performing Operations](https://leetcode.com/problems/final-value-of-variable-after-performing-operations/)

**Description**:

> There is a programming language with onlyÂ **four**Â operations andÂ **one**Â variableÂ `X`:
> 
> - `++X`Â andÂ `X++`Â **increments**Â the value of the variableÂ `X`Â byÂ `1`.
> - `--X`Â andÂ `X--`Â **decrements**Â the value of the variableÂ `X`Â byÂ `1`.
> 
> Initially, the value ofÂ `X`Â isÂ `0`.
> 
> Given an array of stringsÂ `operations`Â containing a list of operations, returnÂ *theÂ **final** value of* `X`Â *after performing all the operations*.

**Answer**:

```python
return sum([-1 if "--" in op else 1 for op in operations])
```

## ğŸ§© Richest Customer Wealth

**Source**: [Richest Customer Wealth](https://leetcode.com/problems/richest-customer-wealth/)

**Description**:

> You are given anÂ `m x n`Â integer gridÂ `accounts`Â whereÂ `accounts[i][j]`Â is the amount of money theÂ `iâ€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹thâ€‹â€‹â€‹â€‹`Â customer has in theÂ `jâ€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹th`â€‹â€‹â€‹â€‹ bank. Return *theÂ **wealth**Â that the richest customer has.*
> 
> A customer'sÂ **wealth**Â is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximumÂ **wealth**.

**Answer**:

```python
return max(map(sum, accounts))
```

## ğŸ§© Defanging an IP Address

**Source**: [Defanging an IP Address](https://leetcode.com/problems/defanging-an-ip-address/)

**Description**:

> Given a valid (IPv4) IPÂ `address`, return a defanged version of that IP address.
> 
> AÂ *defangedÂ IP address*Â replaces every periodÂ `"."`Â withÂ `"[.]"`.

**Answer**:

```python
return address.replace(".", "[.]")
```

## ğŸ§© Maximum Number of Words Found in Sentences

**Source**: [Maximum Number of Words Found in Sentences](https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/)

**Description**:

> AÂ **sentence**Â is a list ofÂ **words**Â that are separated by a single spaceÂ with no leading or trailing spaces.
> 
> You are given an array of stringsÂ `sentences`, where eachÂ `sentences[i]`Â represents a singleÂ **sentence**.
> 
> ReturnÂ *theÂ **maximum number of words**Â that appear in a single sentence*.

**Answer**:

```python
return max(map(len, map(lambda s: s.split(), sentences)))
```
